[
{
	"uri": "https://nymtech.net/docs/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": " Nym is a blockchain-based privacy platform. It provides strong network-level privacy against sophisticated end-to-end attackers, and anonymous transactions using blinded, re-randomizable, decentralized credentials.\nOur goal is to allow developers to enable their applications with advanced privacy features unavailable in other systems.\nNym has a few core technologies, integrated into different types of networked nodes.\n a privacy enhancing signature scheme called Coconut, used in the Nym Validator nodes. a mixnet, which encrypts and mixes network traffic through Nym Mixnodes so that it cannot be determined who is communicating with whom. Our mixnet is based on the Sphinx cryptographic packet format and a modified version of the Loopix mixnet design.  The two technologies ensure privacy at different levels of the stack.\nTransaction privacy In the context of blockchain systems, Coconut provides transaction privacy. Typically this happens by transferring a coin to an address, then creating a privacy-enhanced Coconut credential which provably represents the input amount. The credential can then be \u0026ldquo;spent\u0026rdquo; anonymously, as if it were the original value. Double-spending protections apply to the credential, so it can only be spent once. Nym Validators can then unlock the value so it can be redeemed by the party holding the anonymized credential.\nAlthough there\u0026rsquo;s still work to be done to integrate it against various blockchains, in principle Coconut can anonymize blockchain transactions in any system which provides multi-sig. Bitcoin and Ethereum are obvious first targets here.\nCoconut is very flexible, and can ensure privacy for more than coin transfers; it can ensure privacy for more complex smart contracts as well. Finally, it should be mentioned that Coconut can be applied to non-blockchain systems as well - it\u0026rsquo;s a general purpose technology.\nIP-layer privacy The Nym Mixnet provides privacy at the IP network level.\nWhen you send any data across the internet, it can be tracked by a wide range of observers: your ISP, internet infrastructure providers, large tech companies, and governments.\nEven if the content of the transaction is encrypted, observers can still see that data was transmitted, and gather metadata from unencrypted parts of the data (such as IP routing information). For a public blockchain transaction, it may then be possible to infer message content based on what then becomes visible in e.g. the chain.\nEven though your transaction on-chain may be private (in the case of a privacy-focused blockchain such as ZCash), you may still have problems if your transaction information was captured in transit and its metadata and timing information analyzed.\nThe Nym Mixnet provides very strong security guarantees against this sort of surveillance. It packetizes and mixes together IP traffic from many users inside a mixnet: a decentralized system composed of many mixnodes.\nA mixnet can be used to secure blockchain or non-blockchain systems. Things like crypto-currency wallets are a natural fit for mixnets; but so are non-blockchain things like chat systems.\nIf you\u0026rsquo;re into comparisons, the Nym Mixnet is conceptually similar to other systems such as Tor, but provides improved protections against timing attacks. The Nym mixnet re-orders encrypted, indistinguishable Sphinx packets as they travel through the mixnodes. Our mixnet design based on the Loopix Anonymity System, although slightly modified.\nCoconut Credentials vs Mixnets An application requiring only private credential signing, but no network-level defences, can use Coconut credentials via the Nym Validators.\nConversely, an application that only needs to defend against IP traffic analysis can use the Nym Mixnet by itself, without the Nym Validators.\nBut developers that need end-to-end protection at both the IP network and transaction level can use Coconut and the mixnet together.\n"
},
{
	"uri": "https://nymtech.net/docs/overview/status/",
	"title": "Current Status",
	"tags": [],
	"description": "",
	"content": "We are running a Nym testnet with two main components: Nym Validator nodes, and Nym Mixnodes.\nThere\u0026rsquo;s also a Nym Directory for PKI and network topology information, and a HTML Dashboard showing current network status.\nHere\u0026rsquo;s an overview of the entire network. Don\u0026rsquo;t be frightened, we\u0026rsquo;ll explain each piece!\nEverything shown in the diagram is currently running on the internet, and you\u0026rsquo;re welcome to try our systems out.\nPlease note: the mixnet and credentials system have not yet been connected together (so there is not yet the possibility to protect IP-layer traffic when generating credentials). We\u0026rsquo;re working on it!\n"
},
{
	"uri": "https://nymtech.net/docs/mixnet/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " The mixnet code is relatively simple to build and run on Mac OS X and Linux. We haven\u0026rsquo;t tried it on Windows (yet).\nRequirements  Go 1.12 or later make git  To download and build:\ngit clone https://github.com/nymtech/nym-mixnet.git cd nym-mixnet git checkout v0.1.5 make  In case you\u0026rsquo;ve been traumatized by Go\u0026rsquo;s (lack of) dependency management in the past, you don\u0026rsquo;t need to worry about $GOPATH, $GOROOT etc. Check the code out and build it wherever you want to.\n Output should look like this:\nnym-mixnet$ make make build_client make[1]: Entering directory '/home/dave/Desktop/foo/nym-mixnet' mkdir -p build go build -o build/nym-mixnet-client ./cmd/nym-mixnet-client make[1]: Leaving directory '/home/dave/Desktop/foo/nym-mixnet' make build_mixnode make[1]: Entering directory '/home/dave/Desktop/foo/nym-mixnet' mkdir -p build go build -o build/loopix-mixnode ./cmd/loopix-mixnode make[1]: Leaving directory '/home/dave/Desktop/foo/nym-mixnet' make build_provider make[1]: Entering directory '/home/dave/Desktop/foo/nym-mixnet' mkdir -p build go build -o build/loopix-provider ./cmd/loopix-provider make[1]: Leaving directory '/home/dave/Desktop/foo/nym-mixnet' make build_bench_client make[1]: Entering directory '/home/dave/Desktop/foo/nym-mixnet' mkdir -p build go build -o build/bench-nym-mixnet-client ./cmd/bench-nym-mixnet-client make[1]: Leaving directory '/home/dave/Desktop/foo/nym-mixnet' make build_bench_provider make[1]: Entering directory '/home/dave/Desktop/foo/nym-mixnet' mkdir -p build go build -o build/bench-loopix-provider ./cmd/bench-loopix-provider make[1]: Leaving directory '/home/dave/Desktop/foo/nym-mixnet'  The above commands will check the code out from Github, and then compile six pieces of software into the build/ directory:\nnym-mixnet$ ls build/ bench-nym-mixnet-client bench-loopix-provider nym-mixnet-client loopix-mixnode loopix-provider  Forget about the bench-loopix-* ones for the moment, those are for performance testing. The interesting ones for us right now are:\n the Nym mixnet client, nym-mixnet-client the Nym mixnode, loopix-mixnode the Nym storage node, loopix-provider  In the next sections we\u0026rsquo;ll try each of these out.\n"
},
{
	"uri": "https://nymtech.net/docs/overview/links/",
	"title": "Links",
	"tags": [],
	"description": "",
	"content": "Here are some links that may prove handy as you start exploring our project:\n The Nym website has general info on project status and links to learning materials and talks we\u0026rsquo;ve given Nym Mixnet code Nym Validator code Nym Directory code The Nym dashboard shows testnet nodes and activity You can get a live stream of our testnet mixnode activity by subscribing to the websocket at wss://directory.nymtech.net/ws. View it in-browser here. We have built a Chat client as an example of mixnet integration. If you\u0026rsquo;re a coder, it\u0026rsquo;s easy to build and run. If you\u0026rsquo;re not, we will put releases out once we\u0026rsquo;ve got the GUI running nicely. We have built a QT-based Validator Client to demonstrate the use of Coconut anonymous credentials with the Ethereum Ropsten testnet. You can try to build it yourself, or just download it for Mac and Linux. The Nym directory has Swagger Docs with runnable documentation, so you can easily get an overview of available API methods on the directory server.  "
},
{
	"uri": "https://nymtech.net/docs/mixnet/",
	"title": "Mixnet",
	"tags": [],
	"description": "",
	"content": " Mixnets for network privacy Nym has a mix network, or mixnet, which is composed of mix nodes.\nThe Nym Mixnet implements a modified version of the network anonymity protocols detailed in the Loopix and Sphinx academic papers. It fulfils a similar function to the onion routing in Tor, in that it provides anonymity against attackers who may be monitoring your network traffic or metadata. However, it offers improved protection against adversaries who can monitor the network in its entirety.\nAssume a God-like adversary who can watch every packet on the network, record everything, and analyze everything in real-time. Is it possible to have private communications in such an environment? Intuitively, the answer is no: the attacker can watch every request and response, and progressively identify users with a high degree of success using probabilistic techniques.\nThe Nym Mixnet solves this problem by mixing messages inside network nodes which are opaque to the attacker. Each packet is encrypted, and binary-padded so that it\u0026rsquo;s indistinguishable from all other packets. Incoming packets are \u0026ldquo;mixed\u0026rdquo; with all other messages inside the node. That is, the node strips a layer of packet encryption, and adds a small random transmission delays, so that messages are not emitted in the same order as which they arrived.\nNext, the message is sent to another mix node and mixed again, then to a third mixnode for further mixing. Finally, the message is delivered to its destination.\nEven an attacker who can record the whole internet will not be able to trace the flow of traffic through the system.\nThe Nym Mixnet mitigates against packet-dropping attacks by malicious nodes, and ensures quality-of-service, via loop traffic. Clients send messages which loop back to themselves. This allows clients to assure themselves that messages are being delivered properly. It also provides cover traffic to ensure that enough messages are going through the system to provide privacy.\nApplications that need to defend against network-level monitoring can use the Nym Mixnet - private messaging, VPNs, and other applications to enable strong privacy.\nOur current Mixnet architecture The next few sections will discuss each piece of the puzzle. First, you\u0026rsquo;ll need to build the code so you can try things out.\n"
},
{
	"uri": "https://nymtech.net/docs/mixnet/clients/",
	"title": "Mixnet client",
	"tags": [],
	"description": "",
	"content": " Clients The Nym Client was built in the Installation section. If you haven\u0026rsquo;t yet built the Nym Mixnet and want to run the code on this page, go there first.\n From inside the nym-mixnet directory, the nym-mixnet-client binary got built to the build directory, so you can run it with ./build/nym-mixnet-client:\nnym-mixnet$ ./build/nym-mixnet-client Usage: nym-mixnet-client COMMAND [OPTIONS] _ _ | | ___ ___ _ __ (_)_ __ | | / _ \\ / _ \\| '_ \\| \\ \\/ / | |___ (_) | (_) | |_) | |\u0026gt; \u0026lt; |_____\\___/ \\___/| .__/|_/_/\\_\\ |_| (client) Commands: init Initialise a Loopix client run Run a persistent Loopix client process socket Run a background Loopix client listening on a specified socket Run \u0026quot;nym-mixnet-client help \u0026lt;command\u0026gt;\u0026quot; for more info on a specific command.  As you can see, there are three commands you can issue to the client.\n init - initialize a new client instance run - run a loopix client in the foreground socket - run and listen on a socket for real messages as well  Let\u0026rsquo;s try it out. First, you need to initialize a new client.\nnym-mixnet$ ./build/nym-mixnet-client init --id alice Saved generated private key to /home/you/.loopix/clients/alice/config/private_key.pem Saved generated public key to /home/you/.loopix/clients/alice/config/public_key.pem Saved generated config to /home/you/.loopix/clients/alice/config/config.toml  Have a look at the generated files if you\u0026rsquo;d like - they contain client configurations, public/private keypairs, etc.\nYou can run the client with user alice by doing this:\n./build/nym-mixnet-client run --id alice Our Public Key is: z-OQECd8VgC1BeVi6HsHMUbn3REnqZq1uXcyy9j7Hxc=  It doesn\u0026rsquo;t look like much happened, it just sits there. But in fact, when you run() the client, it immediately starts generating (fake) cover traffic and sending it to the Nym Mixnet.\nCongratulations, you have just contributed a tiny bit of privacy to the world! \u0026lt;CTRL-C\u0026gt; to stop the client.\n Try stopping and starting the client a few times. If you\u0026rsquo;re interested, you should see your traffic reflected in the network traffic sent and received metrics at the Nym Dashboard. Have a look on the right hand side:\nIntegrating the mixnet client in your applications Depending on what language you\u0026rsquo;re using, you can fire up the client in one of two ways.\nIn Go If you\u0026rsquo;re a Gopher, you can compile the client code into your own application in the normal Go fashion. Calling client.Start() and client.SendMessage(message []byte, recipient config.ClientConfig) will allow you to send your traffic over the Nym Mixnet. The ./build/nym-mixnet-client run --id alice command, in fact, just calls client.Start().\nIn other languages If you\u0026rsquo;re not a Gopher (go coder), don\u0026rsquo;t despair. You can run the client in socket mode instead, and use either websockets or TCP sockets. For a websocket, try this:\n./build/nym-mixnet-client socket --id alice --socket websocket --port 1863\nThis will start a websocket connection at ws://localhost:1863/mix. You can push either text or raw bytes down the websocket, and it\u0026rsquo;ll be pushed to the mixnet.\nFor a TCP socket:\n./build/nym-mixnet-client socket --id alice --socket tcp --port 1863\nNo matter whether you use ./nym-mixnet-client run, compile the client into your code, or start a ./nym-mixnet-client socket, the client will reach out and grab the mixnet topology, and immediately start to send fake cover traffic. When you have a real message to send, that\u0026rsquo;ll be sent instead of the cover traffic.\nUnderstanding the client A large proportion of the Nym Mixnet\u0026rsquo;s functionality is implemented client-side, including:\n determining network topology sending Sphinx packets with real messages sending Sphinx packet cover traffic when no real messages are being sent  Determining network topology The first thing to understand is that it\u0026rsquo;s the local client which picks the path that each packet will take through the mixnet topology.\nWhen you first run your client, the client needs to figure what mixnodes exist, which layers they\u0026rsquo;re in, and their public keys.\nThe client asks the Nym directory for the current mixnet topology. The client handles all this automatically, but in order to understand what\u0026rsquo;s happening, you can try it yourself:\ncurl -X GET \u0026quot;https://directory.nymtech.net/api/presence/topology\u0026quot; -H \u0026quot;accept: application/json\u0026quot; | jq  This returns a JSON-formatted list of MixNodes, among other things:\n\u0026quot;MixNodes\u0026quot;: [ { \u0026quot;host\u0026quot;: \u0026quot;3.9.12.238:1789\u0026quot;, \u0026quot;pubKey\u0026quot;: \u0026quot;ALf35HwBzXZXxaS6V55W7cLsx4a26AaRefinwwJHrg4=\u0026quot;, \u0026quot;layer\u0026quot;: 3, \u0026quot;lastSeen\u0026quot;: 1571847181617417500 }, { \u0026quot;host\u0026quot;: \u0026quot;35.178.213.77:1789\u0026quot;, \u0026quot;pubKey\u0026quot;: \u0026quot;KlfEn07FzcN93nMzzlsgq3wN5O1ID6O3Pd4DbezHEWo=\u0026quot;, \u0026quot;layer\u0026quot;: 2, \u0026quot;lastSeen\u0026quot;: 1571847180498272500 }, { \u0026quot;host\u0026quot;: \u0026quot;52.56.99.196:1789\u0026quot;, \u0026quot;pubKey\u0026quot;: \u0026quot;_ObRUsYnHDJOPDHXyfq5bnIoSbdn3BsSRcrLl-FCY1c=\u0026quot;, \u0026quot;layer\u0026quot;: 2, \u0026quot;lastSeen\u0026quot;: 1571847180496028700 }, { \u0026quot;host\u0026quot;: \u0026quot;18.130.86.190:1789\u0026quot;, \u0026quot;pubKey\u0026quot;: \u0026quot;dMtoH6vWDBfwjrU0EzPd-fhZDOGJazELsTp2qLyt72U=\u0026quot;, \u0026quot;layer\u0026quot;: 1, \u0026quot;lastSeen\u0026quot;: 1571847181197982700 }, { \u0026quot;host\u0026quot;: \u0026quot;3.10.22.152:1789\u0026quot;, \u0026quot;pubKey\u0026quot;: \u0026quot;03FFZ5RgfeBPmVVERenJOCLb-yXlOUtstc6izYc-wFs=\u0026quot;, \u0026quot;layer\u0026quot;: 1, \u0026quot;lastSeen\u0026quot;: 1571847180994739500 }, { \u0026quot;host\u0026quot;: \u0026quot;35.176.155.107:1789\u0026quot;, \u0026quot;pubKey\u0026quot;: \u0026quot;oaEqLzA5nUxMAqfg6yW5pneWC342uDMfVsSHxyNQ-DE=\u0026quot;, \u0026quot;layer\u0026quot;: 3, \u0026quot;lastSeen\u0026quot;: 1571847181710269200 } ],  The client does this when it starts. Each node reports what layer it\u0026rsquo;s in, its public key, and its IP address. The client now has all the information needed to pick a path through the mixnet for each Sphinx packet, and do packet encryption.\nSending messages Since it now understands the topology of the mixnet, the client can start sending traffic immediately. But what should it send?\nIf there\u0026rsquo;s a real message to send (because you called client.SendMessage() or poked something down the client\u0026rsquo;s socket connection), then the client will send a real message. Otherwise, the client will send cover traffic, at a rate determined in the client config file in ~/.loopix/clients/\u0026lt;client-id\u0026gt;/config.toml\nReal messages and cover traffic are both encrypted using the Sphinx packet format.\nSphinx packet creation Clients create Sphinx packets. These packets are a bit complicated, but for now all you need to know is that they have the following characteristics:\n they consist of a header and a body the header contains unencrypted routing data bodies are encrypted bodies are padded so that they\u0026rsquo;re all the same size observers can\u0026rsquo;t tell anything about what\u0026rsquo;s inside the encrypted body the body is layer-encrypted - it may contain either another sphinx packet or an unencrypted message  Now let\u0026rsquo;s go build the Nym Mixnode and see what happens when a Sphinx packet hits a mixnode.\n"
},
{
	"uri": "https://nymtech.net/docs/validators/",
	"title": "Validators",
	"tags": [],
	"description": "",
	"content": "Nym Validators provide privacy-enhanced credentials based on the testimony of a set of decentralized, blockchain-based issuing authorities.\nNym Validators use a signature scheme called Coconut. This allows users of the system to generate credentials through decentralised authorities, then use them with service providers.\nFirst, let\u0026rsquo;s take a look at what the Coconut credentials scheme provides, and how it differs from other schemes.\n"
},
{
	"uri": "https://nymtech.net/docs/validators/coconut/",
	"title": "Coconut credentials",
	"tags": [],
	"description": "",
	"content": " Coconut credentials Like centralised credentials, Nym\u0026rsquo;s Coconut credentials can be signed with a secret key and later verified by anybody with the corresponding public key. But Nym credentials are much more powerful than \u0026ldquo;normal\u0026rdquo; signature schemes like standard RSA or DSA.\nSpecifically, Coconut is a blinded, re-randomizable, selective disclosure threshold credential signature scheme. That\u0026rsquo;s quite a mouthful, so let\u0026rsquo;s break it all down into digestible chunks.\nLet\u0026rsquo;s say you have a message in hand. In addition to the normal sign(message, secretKey) and verify(message, publicKey) functions present in other signature schemes, Coconut adds the following:\n1) Blind signatures - disguises message content so that the signer can\u0026rsquo;t see what they\u0026rsquo;re signing. This defends users against signers: the entity that signed can\u0026rsquo;t identify the user who created a given credential, since they\u0026rsquo;ve never seen the message they\u0026rsquo;re signing before it\u0026rsquo;s been blinded (turned into gobbledygook). Coconut uses zero-knowledge proofs so that the signer can sign confidently without seeing the unblinded content of the message.\n2) Re-randomizable signatures - take a signature, and generate a brand new signature that is valid for the same underlying message. The new bitstring in the re-randomized signature is equivalent to the original signature but not linkable to it. So a user can \u0026ldquo;show\u0026rdquo; a credential multiple times, and each time it appears to be a new credential, which is unlinkable to any previous \u0026ldquo;show\u0026rdquo;. But the underlying content of the re-randomized credential is the same (including for things like double-spend protection). This once again protects the user against the signer, because the signer can\u0026rsquo;t trace the signed message that they gave back to the user when it is presented. It also protects the user against the relying party that accepts the signed credential. The user can show re-randomized credentials repeatedly, and although the underlying message is the same in all cases, there\u0026rsquo;s no way of tracking them by watching the user present the same credential multiple times.\n3) Selective disclosure of attributes - allows someone with the public key to verify some, but not all, parts of a message. So you could for instance selectively reveal parts of a signed message to some people, but not to others. This is a very powerful property of Coconut, potentially leading to diverse applications: anonymous voting systems, selective revelation of medical data, etc.\n4) Threshold issuance - allows signature generation to be split up across multiple nodes and decentralised, so that either all signers need to sign (n of n where n is the number of signers) or only a threshold number of signers need to sign a message (t of n where t is the threshold value).\nTaken together, these properties provide excellent privacy for Nym users when it comes to generating and using signatures for cryptographic claims.\n"
},
{
	"uri": "https://nymtech.net/docs/mixnet/mixnodes/",
	"title": "Mixnodes",
	"tags": [],
	"description": "",
	"content": " Mixnodes The Nym Mixnodes were built in the Installation section. If you haven\u0026rsquo;t yet built the Nym Mixnet and want to run the code, go there first.\n You can run the Mix Node from the nym-mixnet directory like this:\n./build/loopix-mixnode Usage: loopix-mixnode COMMAND [OPTIONS] _ _ | | ___ ___ _ __ (_)_ __ | | / _ \\ / _ \\| '_ \\| \\ \\/ / | |___ (_) | (_) | |_) | |\u0026gt; \u0026lt; |_____\\___/ \\___/| .__/|_/_/\\_\\ |_| (mixnode) Commands: run Run a Loopix mixnode Run \u0026quot;loopix-mixnode help \u0026lt;command\u0026gt;\u0026quot; for more info on a specific command.  TODO: finish the first cut of this one\n"
},
{
	"uri": "https://nymtech.net/docs/directory-and-dashboard/",
	"title": "Other Components",
	"tags": [],
	"description": "",
	"content": " Nym Dashboard You can see a simple representation of the overall Nym network at https://dashboard.nymtech.net/. This also shows you a live reading of traffic metrics being sent over the mixnet. The sent and received numbers on each mixnode shows how many packets it has received and sent in the past 1 second.\nNym Directory Note that in the preceding discussions of Nym Validators and Nym Mixnodes, quite a bit is assumed. How does a mixnet client know which nodes exist, and what their IP addresses are? How does it find out their public keys so it can encrypt messages to them, and verify that responses came from them? How can the dashboard measure overall mixnet throughput?\nThe Nym Directory handles all of these concerns:\n presence - each Nym node sends a heartbeat message to the Directory every few seconds so clients know what\u0026rsquo;s running public key infrastructure (PKI) - each node sends its public key as an identifier with the presence messages metrics - if desired, Nym Mixnodes can optionally send information about packets sent/received to the Nym Directory, so we can monitor performance in the testnet. If you would like to implement any Nym Mixnet visualizations, there\u0026rsquo;s a websocket available for metrics at wss://directory.nymtech.net/ws. If you would like to see its output in a browser, go to https://directory.nymtech.net/.  The Nym Directory exposes a simple REST API. Swagger docs are at https://directory.nymtech.net/swagger/index.html\nThe Nym Directory is currently centralised. This is not desirable as it\u0026rsquo;s a single point of failure (or attack) for the system as a whole.\nWhile we\u0026rsquo;re still in early testnet mode, the Nym Directory works well enough to bootstrap the testnet into existence.\nOnce our mixnet Quality of Service system, and Proof of Stake system, they\u0026rsquo;ll take over the functionality of the Directory.\nOther components Other components, not yet built, are currently being designed.\nProof of Stake Nym nodes will rely on a Proof of Stake (PoS) mechanism for both sybil defenses and mixnode quality of service monitoring. This not yet written, primarily because measuring mixnode quality of service for stake slashing was an unsolved problem until very recently.\nMixmining: Quality of Service Monitoring for mixnets The Nym Mixnodes currently incorporate a simple, but individualistic, mechanism for determining quality of service. Connected clients periodically send \u0026ldquo;loop\u0026rdquo; messages to themselves. This provides network cover traffic and also allows each client to check that its messages are getting through.\nThis works reasonably well for a single client, but it breaks down when we want to check quality of service across the system as a whole, in a trustless environment. A client reporting that its messages never made it past Mixnode A could in fact be an attacker who wants to knock the honest, reliable, and perfectly functional Mixnode A out of the network.\nWe have come up with a solution to this problem, allowing auditing of mixnode behaviour across the system as a whole. Once that\u0026rsquo;s working, we will have the ability to stake slash in cases where a Nym Mixnode fails to provide good service.\n"
},
{
	"uri": "https://nymtech.net/docs/mixnet/storage-nodes/",
	"title": "Storage Nodes",
	"tags": [],
	"description": "",
	"content": " Storage nodes The Nym Storage Nodes were built in the Installation section. If you haven\u0026rsquo;t yet built the Nym Mixnet and want to run the code, go there first.\n You can run the Storage node from the nym-mixnet directory like this:\n./build/loopix-provider Usage: loopix-provider COMMAND [OPTIONS] _ _ | | ___ ___ _ __ (_)_ __ | | / _ \\ / _ \\| '_ \\| \\ \\/ / | |___ (_) | (_) | |_) | |\u0026gt; \u0026lt; |_____\\___/ \\___/| .__/|_/_/\\_\\ |_| (provider) Commands: run Run a Loopix provider for offline storage Run \u0026quot;loopix-provider help \u0026lt;command\u0026gt;\u0026quot; for more info on a specific command.  Loopix providers, or storage nodes, provide a destination for mixnet packets. The provider may choose to:\n forward packets to the destination itself - this would make sense in the case of e.g. the Bitcoin blockchain store packets for later retrieval by potentially offline clients - this would make sense for e.g. a chat application  TODO: finish the first cut of this one\n"
},
{
	"uri": "https://nymtech.net/docs/validators/validator-flow/",
	"title": "Validator flow",
	"tags": [],
	"description": "",
	"content": " How do Nym Validators work? If you are a coder and interested in trying it, you can download, build, and run Nym Validator code today. We are also running a small and somewhat creaky testnet publicly. Nym Validators form a network of decentralized nodes:\nHere\u0026rsquo;s the general flow.\nA client (in purple at the bottom) has a message m in hand. The message contains a cryptographic claim. The client blinds the message (to protect the privacy of message content), so now it\u0026rsquo;s got Blinded(m). It then connects to Nym Validators, presents Blinded(m), and asks for a set of signed threshold credentials.\nValidators work together to verify messages, communicating through Tendermint\u0026rsquo;s consensus protocol.\nIf the blinded message Blinded(m) is valid, each validator issues a partial credential. Assuming the signature threshold is met, the client then assembles all of the partial credentials into a single credential Signed(m). From a privacy perspective, this is pretty good: all Nym Validators would need to collude in order to de-anonymize the user. And the validators have never seen the actual message m they\u0026rsquo;ve signed, so that\u0026rsquo;s private too.\nBut it\u0026rsquo;s not perfect, insofar as it\u0026rsquo;s hard but not impossible for validators to collude. So the client can now call randomize(Cm). This converts Signed(m) into a brand-new credential Signed(m)'. The magic part: the underlying message m in both Signed(m) and Signed(m)' can both still be verified independently of which credential it\u0026rsquo;s in. m is always m, even if it\u0026rsquo;s contained in a new, re-randomized signature. This means that in the context of crypto-currency transaction privacy, double-spend protection works.\nRe-randomization is cryptographically inexpensive, so you can happily re-randomize every time you want to show the credential. This makes it impossible for anyone to identify a user by tracing where they\u0026rsquo;ve previously generated or used a specific credential. Calling randomize(Signed(m)) before you show a credential makes each show unlinkable to all previous shows.\nAt this point, the client has Signed(m)', which is essentially a privacy-enhanced bearer token signed by the Nym Validators. The meaning of this depends on the content of m. It might say I\u0026rsquo;m able to pay 2 BTC. It might say I haven\u0026rsquo;t voted in the election yet, here\u0026rsquo;s my vote. Or it might say I\u0026rsquo;m over the age of 18, let me into the pub.\nThe re-randomized credential can then be passed to Service Providers (SPs). SPs are entities external to Nym, which are able to accept signed Nym Credentials and present them to Nym Validators. The Nym Validators will then take appropriate action based on the nature of the presented credential.\nValidator integrations and use cases Note the Ethereum integration at the top of the diagram. At present, Nym Validators monitor public blockchains such as Ethereum, since those present a publicly verifiable set of facts which validators can attest to. Bitcoin support will be added soon. But are blockchain applications the only ones?\nNot at all.\nIn principle, a Nym Validator can monitor and sign for any data source it believes it can trust. While cryptocurrency anonymization and blockchain transaction privacy are obvious use cases, there are many other possibilities.\nFor example, multiple health organisations could co-operate to validate a patient\u0026rsquo;s health record. A patient could then selectively disclose aspects of their health record to interested parties, decrypting some parts of it while keeping others hidden. And the whole process could be anonymized through credential re-randomization, so e.g. different health insurance companies would be unable to monitor and identify a patient when they present their health record (assuming that their name or some rare medical condition is not present).\nCoconut is a general-purpose technology, useful for ensuring transaction privacy in both blockchain and non-blockchain applications.\nSo much for the general flow. Now to the specifics of what\u0026rsquo;s running now.\n"
},
{
	"uri": "https://nymtech.net/docs/mixnet/chat-demo/",
	"title": "Chat demo",
	"tags": [],
	"description": "",
	"content": "You can try out our running mixnet today using a demo application - a mixnet chat demonstrator.\nThe chat client runs as both a console-based client, and as an Electron client showing how you\u0026rsquo;d build something in JavaScript.\nIf you want to try it, grab the code from the chat demo Github repo - build and usage instructions are there. Here\u0026rsquo;s a quick GIF of the console client in action:\n"
},
{
	"uri": "https://nymtech.net/docs/validators/client-demo/",
	"title": "Client Demo",
	"tags": [],
	"description": "",
	"content": " Nym Validator Testnet In the current Nym Validators testnet, we focus primarily on making blockchain transactions private. To demonstrate the technology, we\u0026rsquo;ve set up a Nym ERC20 coin running on the Ethereum Ropsten testnet.\nThe Nym client sends a Nym ERC20 coin to a specific Ethereum address. This locks up the ERC20 coin until it\u0026rsquo;s released by action of the Nym Validators.\nThe client then goes through the credential assembly dance. It creates a cryptographic claim asserting that it transferred Nym ERC20 token(s) into Nym, and sends it to the validators to sign. Validators monitor the Ethereum blockchain, watching for Nym coin transactions, so they\u0026rsquo;re able to verify what happened, and decide whether the client has in fact transferred value, and whether the client has overspent (in which case the credential creation request will be denied).\nRight now, Service Providers are just dummy SPs which demonstrate that credential redemption (and double-spend protection) works.\nClient Demo Client applications interact with Nym Validator nodes through a piece of client software. In order to demonstrate the general flow detailed above, we\u0026rsquo;ve embedded the client in a QT-based GUI application to show how it works.\nTo run it:\n Install dep\nmkdir -p $GOPATH/src/github.com/nymtech cd $GOPATH/src/github.com/nymtech   Git clone the repo at https://github.com/nymtech/qt-validator-client-demo.\ncd qt-validator-client-demo dep ensure  "
},
{
	"uri": "https://nymtech.net/docs/validators/installing-testnet/",
	"title": "Installing a Nym Validator Testnet",
	"tags": [],
	"description": "",
	"content": " Validator internal communication Tendermint is used within Nym validators to prevent double-spending of generated credentials, and zero-knowledge proof to validate cryptocurrency use cases is built into the system at present. More complex smart contract cases will require the coding of specific zero-knowledge proofs to match the application domain of the contract.\nYou don\u0026rsquo;t need to explicitly install Tendermint, it\u0026rsquo;s taken care of by Docker\nBuilding and running a Nym Validator node Install and run in Docker  Install Docker. Install Make. Install dep  Then:\ngo get github.com/nymtech/nym-validator cd $GOPATH/src/github.com/nymtech/nym-validator git fetch --all --tags git checkout tags/v0.12.16 make localnet-build # builds the config directories and docker images docker-compose up -d  All components should now be running (please file a bug report if not).\nYour first Nym Validator request Go to [TODO Jędrzej please put the URL here], download the sample nymclient, and put it somewhere in your PATH.\nNow run ./nymclient -f localnetdata/localclient/config.toml.\nIn the preceding Quickstart, there was a speedy succession of commands to build and run Nym inside docker containers, then hit the containers with the Nym client. If you were able to run all of them without errors, you have made your first Nym request.\nBut what did all of this do? What are the moving parts of a Nym-based system?\nBuilding make localnet-build builds out a configuration directory for a Nym testnet that runs on your local machine. Listing the directory structure gives you this layout of files and directories. Use tree build/ to list the directory tree.\n List the build directory using the tree command. If you don\u0026rsquo;t have tree installed, just poke around using ls.\n $ tree build/  The config directory contains configuration files, as well as private and public keys for multiple components.\nThe components are as follows:\n ethereum-watchers watch the Ethereum blockchain for interesting transactions (such as a user piping Nym ERC20 tokens into Nym). issuers are Coconut credential issuing authorities. nodes are Tendermint blockchain nodes. verifiers are Nym credential verifiers validating any credentials service providers want to deposit. providers are (dummy) external service providers.  Running Nym in Docker docker-compose up -d\n starts Ethereum watchers, which point at the Ropsten testnet starts issuing authorities starts Tendermint nodes starts credential verifiers starts dummy service providers  You can get an idea of what infrastructure you\u0026rsquo;re now running by using docker ps.\n Truncated output of docker ps\n docker ps IMAGE COMMAND PORTS NAMES 88d0b7d0b4ba \u0026quot;/app/provider -f /p…\u0026quot; 0.0.0.0:4100-\u0026gt;4000/tcp, 0.0.0.0:5100-\u0026gt;5000/tcp provider1 88d0b7d0b4ba \u0026quot;/app/provider -f /p…\u0026quot; 0.0.0.0:4101-\u0026gt;4000/tcp, 0.0.0.0:5101-\u0026gt;5000/tcp provider2 298f6b896c69 \u0026quot;/app/issuer -f /iss…\u0026quot; 0.0.0.0:4000-\u0026gt;4000/tcp, 0.0.0.0:5000-\u0026gt;5000/tcp issuer1 298f6b896c69 \u0026quot;/app/issuer -f /iss…\u0026quot; 0.0.0.0:4001-\u0026gt;4000/tcp, 0.0.0.0:5001-\u0026gt;5000/tcp issuer2 298f6b896c69 \u0026quot;/app/issuer -f /iss…\u0026quot; 0.0.0.0:4002-\u0026gt;4000/tcp, 0.0.0.0:5002-\u0026gt;5000/tcp issuer3 2d9126a7090b \u0026quot;/app/nymnode\u0026quot; 0.0.0.0:26659-\u0026gt;26656/tcp, 0.0.0.0:26660-\u0026gt;26657/tcp node1 2d9126a7090b \u0026quot;/app/nymnode\u0026quot; 0.0.0.0:26663-\u0026gt;26656/tcp, 0.0.0.0:26664-\u0026gt;26657/tcp node3 2d9126a7090b \u0026quot;/app/nymnode\u0026quot; 0.0.0.0:26656-26657-\u0026gt;26656-26657/tcp node0 2d9126a7090b \u0026quot;/app/nymnode\u0026quot; 0.0.0.0:26661-\u0026gt;26656/tcp, 0.0.0.0:26662-\u0026gt;26657/tcp node2  Your first Nym credential request So now all the infrastructure is running. How can you make a request for a credential?\nDownload and run the Nym sample client. Go to release page, download the sample nymclient, and put it somewhere in your PATH. Then run:\nnymclient -f $GOPATH/src/github.com/nymtech/nymlocalnetdata/localclient/config.toml.\nWhen the client starts running, the following actions occur:\nInitialization  the client connects to the Ethereum Ropsten testnet the client connects to the Nym Tendermint blockchain  Piping currency into Nym  the client transfers 1 Nym ERC20 token from its own Ethereum address into the Nym \u0026ldquo;pipe\u0026rdquo; account. The \u0026ldquo;from\u0026rdquo; account is specified in the file localnetdata/localclient/clientAccount.key the Nym Ethereum watcher, meanwhile, has been watching the Ethereum chain for any incoming transactions when a threshold number of Watchers have notified Tendermint that they have seen incoming Nym tokens, the incoming tokens are piped into the Tendermint blockchain for use in the Nym system. the user\u0026rsquo;s account in Nym is credited as having 1 Nym token available.  Getting partial Nym credentials to spend on a privacy-enabled service  the user decides to get a credential for 1 Nym token so that it can be spent. the Nym client generates some cryptographic material, and sends it to the Tendermint chain. The issuers monitor this chain and store partial credentials in their datastores. The client may query for it at any future time to retrieve it. Note: anyone may retrieve any credential, but only the client holding the secret for a given credential may use it. the client queries the issuing authorities and retrieves the each partial credential from as many issuing authorities as desired the client recombines the partial credentials, using a secret key generated specifically for this set of partial credentials  The client has retrieved a partial credential from multiple issuing authorities. At this point, those authorities are still able to identify which client requested the credential, so they could potentially identify the client if it tries to spend the credential. To fix this, the client needs to rerandomize.\nRerandomizing and spending the credential  the client re-rerandomizes the assembled credential, outputting a fresh credential containing the same cryptographic claims as the original but which is not linked to the original. the user can now spend this new, re-randomized credential with a service provider the user\u0026rsquo;s client sends the credential to a service provider (SP), along with some extra cryptographic material binding the credential to the SP and providing defense against credential replay attacks.  Validating the credential Validation of the credential being presented by the user is done by the Service Provider, and the Issuing Authorities (IAs).\n the SP receives the credential. the SP does local validation of the credential using the verification key of the relevant Issuing Authorities. the SP sends the credential to the Tendermint nodes to redeem it. the Credential Verifiers, meanwhile, monitor this chain and validate credential in redeem requests when a threshold number of Verifiers have notified Tendermint that given credential was valid, the Tendermint nodes redeem the credential, crediting the SP\u0026rsquo;s account with 1 Nym. This is written to the chain to defend against double spending attacks. at this point, the SP has been paid 1 Nym. The user\u0026rsquo;s client is now free to use the service provided by the SP.  Dummy Service Provider response In in a production system, Service Providers will be run by third parties. But in order to demonstrate the system, we\u0026rsquo;ve built a dummy service provider into a Docker container so that we\n the SP returns \u0026ldquo;true\u0026rdquo; to the client if the redemption request succeeded, and \u0026ldquo;false\u0026rdquo; if the redemption request failed. the client receives the response.  Service logging There is quite a bit going on in the above flow. To see what happening inside each component when nymclient makes its request, you may want to view the logs for each different component.\nTo get a list of containers, run docker ps. Then attach to whichever containers you want to see logs for, e.g:\n docker attach issuer1 docker attach node0 docker attach provider1 docker attach watcher1 docker attach verifier1  Developer documentation Pre-requisites To run the code, follow the standard Go installation procedure as described in https://golang.org/doc/install.\nAll of the required dependencies are attached in the vendor directory.\nTest In order to run tests, simply use the following:\ngo test -v ./...\n"
},
{
	"uri": "https://nymtech.net/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://nymtech.net/docs/",
	"title": "Nym",
	"tags": [],
	"description": "",
	"content": " The Nym Platform Nym is a blockchain-based privacy platform. It provides strong network-level privacy against sophisticated end-to-end attackers, and anonymous transactions using blinded, re-randomizable, decentralized credentials.\nOur goal is to allow developers to enable their applications with advanced privacy features unavailable in other systems.\n"
},
{
	"uri": "https://nymtech.net/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]